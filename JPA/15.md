## 15. 고급 주제와 성능 최적화

이 장에서다루는 내용은 다음과 같다

- 예외처리
- 엔티티 비교
- 프록시 심화 주제
- 성능 최적화

### 15.1 예외처리

#### 15.1.1 JPA 표준 예외 정리

JPA의 표준 예외는 크게 2가지로 나눌 수 있다

- 트랜젝션 롤백을 표시하는 예외
- 트랜젝션 롤백을 표시하지 않는 예외

트랜젝션 롤백을 표시하느 예외는 심각한 예외이므로 복구해선 안된다. 이 예외가 발생하면 트랜잭션을 강제로 커밋해도 트랜잭션이 커밋되지 않고 대신에 `RollbackException`  예외가 발생한다. 반면에 트랜잭션 롤백을 표시하지 않는 예외는 심각한 예외가 아니다. 따라서 개발자가 트랜잭션을 커밋할지 롤백할지를 판단하면 된다.

#### 15.1.2 스프링 프레임워크의 JPA 예외 변환

서비스 계층에서 JPA의 예외를 직접 사용하면 JPA에 의존하게 된다. 스프링 프레임워크는 이런 문제를 해결하려고 데이터 접근 계층에 대한 예외를 추상화해서 개발하자에게 제공한다.

### 15.2 엔티티 비교

영속성 컨텍스트를 통해 데이터를 저장하거나 조회하면 1차 캐시에 엔티티가 저장된다. 같은 영속성 컨텍스트에서 엔티티를 조회하면 항상 같은 엔티티 인스턴스를 반환한다.

### 15.3 프록시 심화 주제

#### 15.3.1 영속성 컨텍스트와 프록시

프록시로 조회한 엔티티의 동일성도 보장한다. 프록시로 조회된 엔티티에 대해서 같은 엔티티를 찾는 요청이 오면 원본 엔티티가 아닌 처음 조회된 프록시를 반환한다.

### 15.4 성능 최적화

#### 15.4.1 N+1 문제

JPQL을 실행하면 JPA는 이것을 즉시 로딩과 지연 로딩에 대해서 전혀 신경 쓰지 않고 JPQL만 사용해서 SQL을 생성한다.

##### 지연로딩과 N+1

모든 회원에 대해 연관된 주문 컬렉션을 사용할 때 발생한다. 주문 컬렉션을 초기화하는 수만큼 sql이 실행된다.

##### 패치 조인 사용

N + 1  문제를 해결하는 가장 일반적인 방법은 패치 조인을 사용하는 것이다. 페치 조인은 SQL 조인을 사용해서 연관된 엔티티를 함께 조회하므로 N+1 문제가 발생하지 않는다.

#### 15.4.2 읽기 전용 쿼리의 성능 최적화

영속성 컨텍스트는 변경 감지를 위해 스냅샷 인스턴스를 보관 하므로 더 많은 메모리를 사용하는 단점이 있다. 읽기 전용으로 엔티티를 조회하면 메모리 사용량을 최적화 할 수 있다

- 스칼라 타입으로 조회

  엔티티가 아닌 스칼라 타입으로 모든 필드를 조회

- 읽기 전용 쿼리 힌트 사용

  `org.hibernate.readOnly` 를 사용하면 엔티티를 읽기 전용으로 조회 할 수 있다. 

- 읽기 전용 트랜잭션 사용

  스프링 프레임워크를 사용하면 트랜잭션을 읽기 전용 모드로 설정할 수 있다.

- 트랜잭션 밖에서 읽기

  트랜잭션을 사용하지 않으면 플러시가 일어나지 않으므로 조회 성능이 향상된다.

#### 15.4.3 배치 처리

##### JPA 등록배치

수천에서 수만 건 이상의 엔티티를 한 번에 등록할 떄 주의할 점은 영속성 컨텍스트에 엔티티가 계속 쌓이지 않도록 일정 단위마다 영속성 컨텍스트의 엔티티를 데이터베이스에 플러시하고 영속성 컨텍스트를 초기화해야한다.

