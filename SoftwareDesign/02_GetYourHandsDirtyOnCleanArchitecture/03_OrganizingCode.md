## 03 코드 구성하기

### 계층으로 구성하기

적어도 세가지 이유로 계층으로 구성하기는 최적의 구조가 아니다.

1. 애플리케이션의 기능 조작이나 특성을 구분 짓는 패키지 경계가 없다

2. 애플리케이션이 어떤 유스케이스들을 제공하는지 파악할 수 없다

   특정 기능을 찾기 위해서는 어떤 서비스가 이를 구현했는지 추측해야 하고, 해당 서비스 내의 어떤 메서드가 그에 대한 책임을 수행하는지 찾아야 한다.

3. 아키텍처를 파악할 수 없다

   어떤 기능이 웹 어댑터에서 호출되는지, 영속성 어댑터가 도메인 계층에 어떤 기능을 제공하는지 한눈에 알아볼 수 없다

### 기능으로 구성하기

패키지 외부에서 접근하면 안되는 클래스들에 대해 package-private 접근 수준을 이용해 패키지 간의 경계를 강화할 수 있다.

계층에 의한 패키징 방식보다 아키텍처의 가시성을 훨씬 더 떨어뜨린다.

package-private 접근 수준을 이용해도 도메인 코드가 실수로 영속성 코드에 의존하는 것을 막을 수 없다.

### 아키텍처적으로 표현력 있는 패키지 구조

구조의 각 요소들은 패키지 하나씩에 직접 매핑된다. 최상위에는 Account 와 관련된 유스케이스를 구현한 모듈임을 나타내는 account 패키지가 있다

그다음 레벨에는 도메인 모델이 속한 domain 패키지가 있다

만약 패키지 구조가 아키텍처를 반영할 수 없다면 시간이 지남에 따라 코드는 점점 목표하던 아키텍처로부터 멀어지게 될 것이다.

어뎁터 패키지는 application 패키지 내에 있는 포트를 통하지 않고는 바깥에서 호출되지 않기 때문에 package-private 접근 수준으로 둬도 된다

### 의존성 주입의 역할

클린 아키텍처의 가장 본질적인 요건은 애플리케이션 계층이 인커밍/아웃고잉 어댑터에 의존성을 갖지 않는 것이다.

포트 인터페이스를 구현한 실제 객체를 누가 애플리케이션 계층에 제공해야할까

이 부분에서 의존성 주입을 활용할 수 있다. 모든 계층에 의존성을 가진 중립적인 컴포넌트를 하나 도입하는 것이다.