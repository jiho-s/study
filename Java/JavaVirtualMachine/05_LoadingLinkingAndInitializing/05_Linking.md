## 링킹

클래스 또는 인터페이스 링킹에는 해당 클래스 또는 인터페이스, 필요한 경우 직접 연결된 슈퍼클래스, 직접 연결된 슈퍼인터페이스 및 요소 타입 (배열 타입인 경우)을 검증하고 준비하는 작업이 포함된다. 링킹에는 클래스 또는 인터페이스의 심볼릭 참조 검증도 포함되지만 클래스 또는 인터페이스가 검증되고 준비되는 동시에 반드시 필요한 것은 아니다.

이 사양은 다음 속성이 모두 유지되는 경우 링크 활동 (및 재귀,로드로 인해)이 발생할 때 구현 유연성을 허용한다.

- 클래스 또는 인터페이스는 링크되기 전에 완전히 로드된다.
- 클래스 또는 인터페이스는 초기화되기 전에 완전히 검증되고 준비된다.
- 링킹 중에 감지 된 오류는 프로그램에서 직접 또는 간접적으로 오류와 관련된 클래스 또는 인터페이스에 대한 링킹이 필요할 수있는 일부 작업을 수행하는 지점에서 발생한다.
- 동적으로 계산 된 영역 호출 대한 심볼릭 참조는 이를 정적 인수로 참조하는 부트 스트랩 메서드가 호출 될 때까지 확인되지 않는다.

예를 들어, Java Virtual Machine 구현은 클래스 또는 인터페이스의 각 심볼릭 참조가 사용될 때 개별적으로 확인되는 "lazy"연결 전략을 선택할 수 있다. 다른 방면으로, 구현은 클래스 또는 인터페이스가 검증 될 때 모든 심볼릭 참조가 한 번에 해결되는 "eager" 연결 전략을 선택할 수 있다. 이는 일부 구현에서 클래스 또는 인터페이스가 초기화 된 후에도 검증 프로세스가 계속 될 수 있음을 의미한다. 어떤 전략을 따르든, 해결 중에 감지된 오류는 (직접 또는 간접적으로) 클래스나 인터페이스에 대한 심볼릭 참조를 사용하는 프로그램의 한 지점에 던져져야 한다.

### 검증

검증은 클래스 또는 인터페이스의 이진 표현이 구조적으로 올바른지 확인한다.

클래스 또는 인터페이스의 이진 표현이 나열된 정적 또는 구조적 제약 조건을 충족하지 않는경우 클래스 또는 인터페이스를 확인하게 만든 프로그램의 지점에서  `VerifyError`를 던져야 한다.

### Preparation

Preparation에는 클래스 또는 인터페이스에 대한 static 필드를 만들고 이러한 필드를 기본값으로 초기화하는 작업이 포함된다. 이는 Java Virtual Machine 코드를 실행할 필요가 없다. 정적 필드에 대한 명시적 initializers는  Preparation가 아닌 initialization의 일부로 실행된다.

준비는 생성 후 언제든지 발생할 수 있지만 초기화 전에 완료해야한다.

### Resolution

대부분의 자바 가상 머신 명령은 런타임 상수 풀의 심볼릭 참조에 의존한다. 이러한 명령을 실행하려면 심볼릭 참조를 해결(resolution) 해야한다.

Resolution은 런타임 상수 풀의 심볼릭 참조에서 하나 이상의 구체적인 값을 동적으로 결정하는 프로세스이다. 처음에는 런타임 상수 풀의 모든 기호 참조가 해결되지 않는다.

(i) 클래스 또는 인터페이스, (ii) 필드, (iii) 메서드, (iv) 메서드 타입, (v) 메서드 핸들, (vi) 동적으로 계산 된 상수에 대한 해결되지 않은 심볼릭 참조의 해결은 아래의 규칙에 따라 진행된다.

####  클래스 및 인터페이스 Resolution

클래스 또는 인터페이스 C 로의 해석되지 않은 D에서의 기호 참조를 해석하려면 다음 단계를 수행한다.

1. D의 정의 클래스 로더는 `N`으로 표시된 클래스 또는 인터페이스를 만드는 데 사용된다. 생성된 클래스 또는 인터페이스는 C 이다. 
2. C가 배열 타입이고 요소 타입이 reference 타입인 경우, 요소 타입을 나타내는 클래스 또는 인터베이스의 심볼릭 참조를 클래스 및 인터페이스 resolution을 재귀적으로 호출하여 수행한다.
3. D 에서 C의 접근이 접근제어에 적용된다.

#### 필드 Resolution

필드 참조를 확인할 때 필드 확인은 먼저 C 및 해당 수퍼 클래스 에서 참조 된 필드를 조회하려고 한다.

1. C가 필드에 대한 이름과 서술로 되어있므면, 필드 조회는 성공했다. 선언 된 필드는 필드 조회의 결과이다.
2. 그렇지 않으면 필드 조회가 지정된 클래스 또는 인터페이스 C의 직접 연결된 수퍼 인터페이스에 재귀적으로 적용된다.
3. 그렇지 않고 C에 수퍼 클래스 S가 있으면, 필드 조회가 S 에 재귀 적으로 적용된다.
4. 그렇지 않으면 필드 조회가 실패합니다.

그런 다음 필드 Resolution의 결과가 결정된다.

- 필드 조회가 실패하면 필드 검증에서 `NoSuchFieldError`.
- 그렇지 않으면, 필드 조회가 성공했다. D 에서 필드 조회의 결과인 필드로의 액세스에 대해 액세스 제어가 적용된다. 

####  메소드 Resolution

1. C가 인터페이스 인 경우, 메소드 resolution은 `IncompatibleClassChangeError`를 던진다.
2. 그렇지 않으면, 메소드 resolution은 C 및 해당 수퍼 클래스 에서 참조된 메서드를 찾으려고한다.
   - C가 메소드 레퍼런스에 서술된 이름을 가진 메소드를 정확히 하나만 선언한 경우, 그리고 그 선언이 다형성을 만족하는 메소드인 경우, 메소드 조회는 성공이다.
   - 그렇지 않으면, C가 메소드 레퍼런스에 서술된 이름을 가진 메소드를 선언한 경우, 메소드 조회는 성공이다.
   - 그렇제 않고, C가 슈퍼클래스를 가지면, C에 직접 연결된 슈퍼클래스에서 메소드 Resoltuion의 2과정을 재귀적으로 실행한다.
3. 그렇지 않으면, 메서드 resolution은 지정된 클래스 C 의 수퍼 인터페이스에서 참조 된 메서드를 찾으려고 시도한다.
   - 메소드 참조에 의해 서술된 이름 및 설명을 가진 C의 가장 명확한 슈퍼인터페이스 메서드가 하나만 존재하고, 해당 메소드가 `ACC_ABSTRACT` 플래그가 설정되지 않은 경우, 해당 메소드가 선택되고 메소드 조회는 성공이다.
   - 그렇지 않으면, 메소드 참조에 의해 서술된 이름 및 설명을 가진 C의 슈퍼인터페이스의 메소드 중 어떤것이 `ACC_PRIVATE`, `ACC_STATIC` 플래그가 모두 설정되어 있지 않으면 이들 중 하나가 임의로 선택되고 메소드 조회가 성공한다.
   - 그렇지 않으면, 메소드 조회가 실패한다.

메소드 Resolution의 결과는 다음과 같이 결정된다.

- 메소드 조회가 실패하면 메소드 검증에서 `NoSuchMethodError`.
- 그렇지 않으면, 메소드 조회가 성공했다. D 에서 메소드 조회의 결과인 메소드로의 액세스에 대해 액세스 제어가 적용된다. 

#### 인터페이스 메소드 Resolution

1. C가 인터페이스가 아닌 경우, 인터페이스 메소드 resolution은 `IncompatibleClassChangeError`를 던진다.
2. 그렇지 않고, 인터페이스 메서드 참조에 지정된 이름과 설명자를 가진 메서드를  C 가 선언하고 있으면, 메서드 조회가 성공한다.
3. 그렇지 않고,  `ACC_PUBLIC`플래그가 설정되어 있고 `ACC_STATIC` 플래그가 설정되지 않고, 인터페이스 메서드 참조에 의해 지정된 이름 및 서술된 메서드를 클래스 `Object`가 선언하고 있으면, 메서드 조회가 성공한다.
4. 인터페이스 메소드 참조에 의해 서술된 이름 및 설명을 가진 C의 가장 명확한 슈퍼인터페이스 메서드가 하나만 존재하고, 해당 메소드가 `ACC_ABSTRACT` 플래그가 설정되지 않은 경우, 해당 메소드가 선택되고 메소드 조회는 성공이다.
5. 그렇지 않으면, 인터페이스 메소드 참조에 의해 서술된 이름 및 설명을 가진 C의 슈퍼인터페이스의 메소드 중 어떤것이 `ACC_PRIVATE`, `ACC_STATIC` 플래그가 모두 설정되어 있지 않으면 이들 중 하나가 임의로 선택되고 메소드 조회가 성공한다.
6. 그렇지 않으면, 메소드 조회가 실패한다.

### 접근 제어

클래스, 인터페이스, 필드 또는 메서드에 대한 참조가 허용되도록 resolution 중에 액세스 제어가 적용 된다. 지정된 클래스, 인터페이스, 필드 또는 메서드가 참조하는 클래스 또는 인터페이스에 *액세스 할 수* 있으면 액세스 제어가 성공한다.

클래스 또는 인터페이스 C 는 다음 중 하나에 해당하는 경우에만 클래스 또는 인터페이스 D에 액세스 할 수 있다.

- C 는 `public`이며 D와 동일한 런타임 모듈인 경우.
- C 는 `public`이고 D 와 다른 런타임 모듈의 멤버 이며 C 의 런타임 모듈은 D 의 런타임 모듈에서 읽고 C 의 런타임 모듈은 C 의 런타임 패키지를 내보내어 D 의 런타임 모듈에 추가한 경우.
- C는  `public`이 아니며, C 와 D는 같은 런타임 패키지인 경우.