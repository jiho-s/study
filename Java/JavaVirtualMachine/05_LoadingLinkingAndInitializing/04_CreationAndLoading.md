## 생성과 로딩

N이라는 이름으로 표시된 클래스 또는 인터페이스 C의 생성은 자바 가상 머신의 구현별 내부 표현의 C의  메소드 영역에 있는 구조로 구성된다. 클래스 또는 인터페이스 생성은 런타임 상수 풀을 통해 C 를 참조 하는 다른 클래스 또는 인터페이스 D 에 의해 트리거되어 생성된다. 클래스 또는 인터페이스 생성은 리플렉션과 같은 특정 Java SE 플랫폼 클래스 라이브러리의 호출 메서드에 의해 트리거 될 수도 있다.

C 가 배열 클래스가 아닌 경우 클래스 로더가 C의 이진 표현을 로드하여 생성된다. 배열 클래스에는 이진 표현이 없고, 클래스 로더가 아닌 Java Virtual Machine에 의해 생성된다.

클래스 로더에는 Java Virtual Machine에서 제공하는 부트 스트랩 클래스 로더와 사용자 정의 클래스 로더의 두 가지 종류가 있습니다. 모든 사용자 정의 클래스 로더는 추상 클래스의 하위 클래스 인스턴스입니다 `ClassLoader`. 애플리케이션은 Java Virtual Machine이 동적으로로드하여 클래스를 작성하는 방식을 확장하기 위해 사용자 정의 클래스 로더를 사용합니다. 사용자 정의 클래스 로더를 사용하여 사용자 정의 소스에서 생성 된 클래스를 만들 수 있습니다. 예를 들어, 클래스는 네트워크를 통해 다운로드되거나 즉시 생성되거나 암호화 된 파일에서 추출 될 수 있습니다.

클래스 로더에는 Java Virtual Machine에서 제공하는 부트 스트랩 클래스 로더와 사용자 정의 클래스 로더의 두 가지 종류가 있다. 모든 사용자 정의 클래스 로더는 추상 클래스 `ClassLoader`의 하위 클래스 인스턴스입니다. 애플리케이션은 Java Virtual Machine이 동적으로 로드하여 클래스를 작성하는 방식을 확장하기 위해 사용자 정의 클래스 로더를 사용한다. 사용자 정의 클래스 로더를 사용하여 사용자 정의 소스에서 생성 된 클래스를 만들 수 있다. 예를 들어, 클래스는 네트워크를 통해 다운로드되거나 즉시 생성되거나 암호화 된 파일에서 추출 될 수 있다.

클래스 로더 `L`는 직접 정의하거나 다른 클래스 로더에 위임하여 C 를 작성할 수 있다.

### 부트 스트랩 클래스 로더를 사용하여로드

Java Virtual Machine은 부트 스트랩 클래스 로더가  `N`로 표시된 클래스 또는 인터페이스의 시작 로더로 이미 기록되었는지 여부를 판단한다. 기록되어 있으면, 클래스 또는 인터페이스는 C이므로 생성할 필요가 없다

기록되어있지 않다면, Java Virtual Machine은 플랫폼 종속 방식으로 C의 의도 된 표현을 검색하기 위해 부트 스트랩 클래스 로더의 메소드 호출에 `N` 인수 를 전달한다. 일반적으로 클래스 또는 인터페이스는 계층 적 파일 시스템의 파일을 사용하여 표현되며 클래스 또는 인터페이스의 이름은 파일의 경로 이름으로 인코딩된다.

발견 된 것으로 알려진 표현이 유효하거나 C 의 표현이라는 보장은 없다. 만약 없으면 `ClassNotFoundException` 가 발생한다.

그런 다음 Java Virtual Machine은 의도 된  `N`표현에서 부트 스트랩 클래스 로더를 사용하여 표시된 클래스를 만든다. 

### User-defined Class Loader를 사용하여 로드

Java Virtual Machine은  `L` 로더가 `N`로 표시된 클래스 또는 인터페이스의 시작 로더로 이미 기록 되었는지 여부를 확인한다.