## 생성과 로딩

N이라는 이름으로 표시된 클래스 또는 인터페이스 C의 생성은 자바 가상 머신의 구현별 내부 표현의 C의  메소드 영역에 있는 구조로 구성된다. 클래스 또는 인터페이스 생성은 런타임 상수 풀을 통해 C 를 참조 하는 다른 클래스 또는 인터페이스 D 에 의해 트리거되어 생성된다. 클래스 또는 인터페이스 생성은 리플렉션과 같은 특정 Java SE 플랫폼 클래스 라이브러리의 호출 메서드에 의해 트리거 될 수도 있다.

C 가 배열 클래스가 아닌 경우 클래스 로더가 C의 이진 표현을 로드하여 생성된다. 배열 클래스에는 이진 표현이 없고, 클래스 로더가 아닌 Java Virtual Machine에 의해 생성된다.

클래스 로더에는 Java Virtual Machine에서 제공하는 부트 스트랩 클래스 로더와 사용자 정의 클래스 로더의 두 가지 종류가 있습니다. 모든 사용자 정의 클래스 로더는 추상 클래스의 하위 클래스 인스턴스입니다 `ClassLoader`. 애플리케이션은 Java Virtual Machine이 동적으로로드하여 클래스를 작성하는 방식을 확장하기 위해 사용자 정의 클래스 로더를 사용합니다. 사용자 정의 클래스 로더를 사용하여 사용자 정의 소스에서 생성 된 클래스를 만들 수 있습니다. 예를 들어, 클래스는 네트워크를 통해 다운로드되거나 즉시 생성되거나 암호화 된 파일에서 추출 될 수 있습니다.

클래스 로더에는 Java Virtual Machine에서 제공하는 부트 스트랩 클래스 로더와 사용자 정의 클래스 로더의 두 가지 종류가 있다. 모든 사용자 정의 클래스 로더는 추상 클래스 `ClassLoader`의 하위 클래스 인스턴스입니다. 애플리케이션은 Java Virtual Machine이 동적으로 로드하여 클래스를 작성하는 방식을 확장하기 위해 사용자 정의 클래스 로더를 사용한다. 사용자 정의 클래스 로더를 사용하여 사용자 정의 소스에서 생성 된 클래스를 만들 수 있다. 예를 들어, 클래스는 네트워크를 통해 다운로드되거나 즉시 생성되거나 암호화 된 파일에서 추출 될 수 있다.

클래스 로더 `L`는 직접 정의하거나 다른 클래스 로더에 위임하여 C 를 작성할 수 있다.

### 부트 스트랩 클래스 로더를 사용하여로드

Java Virtual Machine은 부트 스트랩 클래스 로더가  `N`로 표시된 클래스 또는 인터페이스의 시작 로더로 이미 기록되었는지 여부를 판단한다. 기록되어 있으면, 클래스 또는 인터페이스는 C이므로 생성할 필요가 없다

기록되어있지 않다면, Java Virtual Machine은 플랫폼 종속 방식으로 C의 의도 된 표현을 검색하기 위해 부트 스트랩 클래스 로더의 메소드 호출에 `N` 인수 를 전달한다. 일반적으로 클래스 또는 인터페이스는 계층 적 파일 시스템의 파일을 사용하여 표현되며 클래스 또는 인터페이스의 이름은 파일의 경로 이름으로 인코딩된다.

발견 된 것으로 알려진 표현이 유효하거나 C 의 표현이라는 보장은 없다. 만약 없으면 `ClassNotFoundException` 가 발생한다.

그런 다음 Java Virtual Machine은 의도 된  `N`표현에서 부트 스트랩 클래스 로더를 사용하여 표시된 클래스를 만든다. 

### User-defined Class Loader를 사용하여 로드

Java Virtual Machine은  `L` 로더가 `N`로 표시된 클래스 또는 인터페이스의 시작 로더로 이미 기록 되었는지 여부를 확인한다.

기록되어 있지 않으면 Java Virtual Machine이에서 호출 한다. 호출에서 반환 된 값은 생성 된 클래스 또는 인터페이스 C다. Java Virtual Machine은 C의 시작 로더를 L이라고 기록한다.

로드될 클래스 또는 인터페이스 C의 N이란 이름으로 클래스 로더 L의 `loadClass` 메소드를 호출할때, C를 로드 할 때 다음과 같은 동작중 하나를 수행해야 한다.

- 클래스 로더 `L` 는 `ClassFile` 구조 의 바이트로 부터 `C`를 나타내는 바이트 배열을 만들 수 있다. 그런 다음 `ClassLoader`클래스의 `defineClass`메소드를 호출한다. `defineClass`를 호출하면, Java Virtual Machine이 `L`을 사용하여 `N`으로 나타내는 클래스 또는 인터페이스를 만든다.
- 클래스 로더 `L` 는 C 의 로딩을 다른 클래스 로더 `L`'로 위임 할 수 있다 . 이는 인수 `N`를 `L`'(일반적으로 `loadClass`메서드) 의 메서드 호출에 직접 또는 간접적으로 전달하여 수행된다 . 호출 결과는 C이다.

### 배열 클래스 생성

`N`과 같은 구성 요소 타입을 가진 배열 클래스의 시작 로더로 `L`이 이미 기록 된 경우 해당 클래스는 C 이며 배열 클래스 생성이 필요하지 않다.

그렇지 않으면 다음 단계를 수행하여 C를 생성한다.

- 구성 요소 타입이 `reference`타입 인 경우 클래스 로더 `L`를 사용하여 재귀적으로 C 구성 요소 타입을 로드하고 생성한다 .

- Java Virtual Machine은 표시된 구성 요소 타입과 차원 수를 사용하여 새 배열 클래스를 만든다.

  컴포넌트 타입이 `reference`타입 인 경우 C 는 구성된 타입을 정의한 클래스 로더에 의해 정의 된 것으로 표시된다. 그렇지 않으면 C 는 부트 스트랩 클래스 로더에 의해 정의 된 것으로 표시된다.

  Java Virtual Machine은 C에 대한 시작 로더  `L`을 기록한다.

  구성 요소 타입이 `reference`유형 인 경우 배열 클래스의 액세스 가능성은 해당 구성 요소 타입의 액세스 가능성에 의해 결정된다 . 그렇지 않으면 모든 클래스와 인터페이스에서 배열 클래스에 액세스 할 수 있다.

### `class` 파일 표현에서 클래스 유도

다음 단계는 `class` 파일 형식의 표현에서 로더 `L` 을 사용하여 표시되는 비배열 클래스 또는 인터페이스 C에 대한  `Class` 객체 를 이끌어네는데 사용된다.

1. 먼저 Java Virtual Machine은 `N`으로 표시되는 클래스 또는 인터페이스의 시작 로더  `L`을 이미 기록했는지 여부를 확인한다. 그렇다면, 이 생성 시도는 유효하지 않으며 로드시 `LinkageError`가 발생한다.

2. 그렇지 않으면 Java Virtual Machine이 의도 된 표현을 구문 분석하려고한다. 그러나 의도 된 표현은 실제로 C 의 유효한 표현이 아닐 수 있다.

   로딩 단계는 다음 오류를 감지해야합니다.

   - 서술된 표현이  `ClassFile` 구조가 아닌 경우, 로딩은 `ClassFormatError` 인스턴스의 에러를 던진다 .

   - 또는, 서술된 표현이 지원되는 버전이 아닌 경우, 로드하면 `UnsupportedClassVersionError`를 던진다.

   - 또는, 서술된 표현이 실제로 `N`이라는 클래스를 나타내지 않는 경우,  로딩시  `NoClassDefFoundError` 인스턴스 또는 하위 클래스 중 하나의 인스턴스를 throw한다.

     서술된 표현에 `this_class`이 아닌 이름을 지정하는 `access_flags`항목 또는 `ACC_MODULE`플래그가 설정된 항목 의  `N`이있을 때 발생한다 .

3. C는 직접 연결된 슈퍼클래스를 가지면, C에서 슈퍼클래스로의 심볼릭 주소로 해결된다. C가 인터페이스인 경우, 이미 로드된 직접적인 슈퍼클래스인 `Object`가 있어야한다. 단, `Object`는 직접 연결된 슈퍼 클래스가 없다.

   클래스 또는 인터페이스 확인으로 인해 throw 될 수있는 모든 예외는 이 로딩 단계의 결과로 throw 될 수 있다. 또한 다음의 오류가 발생할 수 있다.

   - C 의 직접 연결된 수퍼 클래스로 명명 된 클래스 또는 인터페이스가 실제로 인터페이스 인 경우 로드하면 `IncompatibleClassChangeError`가 발생한다.
   - 또는, C 의 수퍼 클래스 중 하나 가 C 자체 인 경우로드하면 `ClassCircularityError`가 발생한다.

4. C 에 직접 연결된 슈퍼인터페이스가 있는 경우 C 에서 직접적인 슈퍼인터페이스로의 심볼릭 주소로 해결된다.

   클래스 또는 인터페이스 확인으로 인해 throw 될 수있는 모든 예외는이로드 단계의 결과로 throw 될 수 있다. 도한, 다음의 오류가 발생할 수 있다.

   - C의 직접 수퍼 인터페이스로 명명 된 클래스 또는 인터페이스가 실제로 인터페이스가 아닌 경우 로드하면 `IncompatibleClassChangeError`.
   - 또는, C 의 수퍼 인터페이스 중 하나 가 C 자체이면 로드하면 `ClassCircularityError`.

5. Java Virtual Machine은  `L`이 C를 정의한 클래스 로더라고 기록한다.

