## Garbage-First Garbage Collector

G1(Garbage-First) 가비지 컬렉터는 많은 양의 메모리가 있는 멀티 프로세서 시스템을 대상으로 한다. 최소한의 설정으로 높은 처리향을 달성하면서 가비지 컬랙션 일시 중지 시간 목표를 높은 확률로 달성하고자 한다. G1은 현재 애플리케이션 및 아래의 환경을 대상으로 지연 시간과 처리량 사이의 최상의 균형을 제공하는것을 목표로 한다.

- 힙의 크기는 10 GB이상이며, 50% 이상의 Java 힙은 접근 가능한 데이터가 차지한다.
- 객체 할당과 승격 비율은 시간에 따라 달라질 수 있다.
- 힙에 많은 fragmentation이 존재한다.
- 수백 밀리 초를 넘지 않는 예측 가능한 일시 중지 시간을 목표로, 깁 가비지 컬렉션 일시 중지를 방지한다.

### G1 활성화

Garbage-First 가비지 수집기는 기본 수집기이므로 추가적인 작업이 필요 없다. `-XX:+UseG1GC`를 이용하여 명시적으로 활성화 할 수 있다.

### 기본 개념

G1은 세대별, 증분식, 병렬, 대부분 동시, stop-the-world, 비우기 가비지 컬렉터로, 각각의 stop-the-world 일시 중지 시간안에 일시 중지 시간을 모니터링한다. 다른 컬렉터와 마찬가지로 G1은 힙을 young 세대와 old 세대로 나눈다. 공간 재 확보는 가장 효율적인 young 세대에 집중하고, 적은 빈도로 old 세대에서 공간 재 확보를 한다.

일부 작업은 처리량을 향상 시키기 위해 항상 stop-the-world 일시 중지로 수행된다. *global marking* 같은 전체 힙 작업과 같이 애플리케이션이 중지된 상태에서  더 많은 시간이 걸리는 작업은 애플리케이션과 동시에 수행된다. 공간 재 확보를 위한 stop-the-world 일시 중지 시간을 짧게 유지하기 위해 G1은 공간 재확보를 병렬로 점진적으로 수행한다. G1은 관련 비용 모델을 만들기 위해 이전 애플리케이션 동작 및 일시 중지에 대한 정보를 추적하여 예측한다. 예측 정보를 통해 중지시 작업의 양에 대한 정보를 얻는다.

G1은 evacuation을 사용하여 공간을 회수한다. 선택된 메모리 영역에서 찾은 접근 가능한 객체를 새 메모리 영역으로 복사되어 프로세스에 의해 압축된다.  evacuation 이 완료된 후에, 이전에 접근 가능한 객체가 차지 했던 공간이 애플리케이션에서 할당을 위해 제사용된다.

G1 컬렉터는 real-time 컬렉터가 아니다. 높은 확률로 설정된 일시 중지 시간 목표를 달성하려고 시도한다. 하지만 목표를 달성할지 확신할 수 없다.

#### 힙 레이아웃

G1은 힙을 동일한 크기의 힙 영역으로 분할한다. 각 힙영역은 연속적인 가상 메모리이다. 영역은 메모리 할당 및 메모리 재확보의 단위이다. 이러한 각 영역은 비어 있거나 특정 세대(old 또는 young)에 할당 될 수 있다. 메모리 요청이 들어 오면 메모리 매니져는 사용 가능한 영역을 나눠 준다.

young 세대는 에덴지역과 서바이버 지역을 포함한다. 이러한 영역은 다른 컬렉터에서도 동일한 기능을 제공하지만, G1에서는 이러한 영역이 비연속적인 패턴으로 배치된다. old 세대는 old 지역으로 구성된다. old 세대 지역은 여러 힙 영역일 수 있고 여러개 있다.

old 세대에 직접 할당된 큰 객체를 제외하고는 애플리케이션은 항상 young 세대, 에덴 지역에 할당된다. 

G1 컬렉터 컬렉션 일시 중지는 전체적인 young 세대의 공간을 회수 할 수 있으며 컬렉션 일시 중지시 old세대 영역의 집합을 추가적으로 회수 할 수 있다. 일시 중지 중에 G1은 컬렉션 집합의 객체를 하나 또는 하나 이상의 다른 힙 영역으로 복사한다. young 세대의 살아남은 객체는 old 지역으로 복사되고, old 지역의 객체는 aging을 사용하여 다른 old 지역으로 복사된다.

#### 가비지 컬렉션 사이클

크게 보면, G1 컬렉터는 두 단계를 번갈아 가며 수행한다. young 전용 단계에서는 현재 사용가능한 객체의 메모리를 old 세대로 점진적으로 채우는 가비지 컬렉션이 포함된다. 공간회수 단계에서는 young 세대를 처리하는 것에 추가로, old 세대의 공간을 점진적으로  재확보 하는 단계이다. 그런 다음 다시 young 전용 단계로 다시 시작된다.

다음 목록은 G1 가비지 컬렉션 사이클의 단계사이의 일시중지 변화 등을 자세히 설명한다.

1. young 전용 단계

   이 단계는 일부의 young 세대 컬렉션을 old 세대로 옮기는것으로부터 시작된다. old 세대 점유율이 `Initiating Heap Occupancy`를 넘으면 공간회수 단계에서 young 전용 단계로 전환된다. G1은 `Normal young Collection` 대신, `Concurrent Start young collection`를 스케줄한다.

   - `Concurrent Start`

     Normal young collection을 수행하고 추가적으로 마킹 프로세스를 시작한다. 동시 마킹은 old 세대 영역에서 현재 도달 할 수있는 모든 객체를 다음 공간 회수 단계 동안 유지하도록 결정한다. 컬렉션 마킹이 완전히 완료되지 않아도 Normal young collection이 발생할 수 있다. 마킹은 두 가지 특별한 stop-the-world 일시 중지(`Remark` 와 `Cleanup`)로 완료된다

   - `Remark`

     마킹 자체를 마무리하고 글로벌 참조 처리 및 클래스 언로드를 수행하며 완전히 빈 영역을 회수하고 내부 데이터 구조를 정리한다. `Remark`와 `Cleanup` 사이 G1은 선택된 old 세대 영역에서 여유 공간을 동시에 회수 할 수 있도록 정보를 계산하며, 이는 `Cleanup` 일시 중지에서 마무리된다.

   - `Cleanup`

     공간 회수 단계가 실제로 뒤따를 지 여부를 결정합니다. 공간 재 확보 단계가 뒤 따르면 Young 전용 단계는 단일 Prepare Mixed Young 컬렉션으로 완료된다. 

2. 공간 재 확보 단계

   이 단계는 young 세대 지역 외에도 old 세대 지역 집합의 라이브 객체를 비우는 여러 혼합 컬렉션으로 구성된다. 공간 재 확보 단계는 G1이 더 많은 old 세대 영역을 비워도 충분한 여유 공간을 확보하지 못할 것이라고 판단 할 때 종료된다.

공간 재 확보 후 수집 단계는 다른 young 전용 단계로 다시 시작된다. 살아있는 객체의 정보를 수집하는 동안 애플리케이션의 메모리가 부족하면 G1은 다른 수집기와 마찬가지로 전체 GC (stop-the-world full heap compaction)를 수행한다.

### Garbage-First 내부구조

#### Initiating Heap Occupancy 설정

*Initiating Heap Occupancy Percent*(IHOP) 는 Initial Mark collection이 시작되는 지점이다. 이는 old 세대 크기의 비율로 정의된다.

기본적으로 G1은 마킹에 걸리는 시간과 마킹주기 동안 old 세대에 일반적으로 할당 된 메모리 양을 관찰하여 최적의 IHOP를 자동으로 결정한다. 이 기능을 *Adaptive IHOP* 라고 한다. 이 기능이 활성화 된 경우에 옵션 `-XX:InitiatingHeapOccupancyPercent`은 Initiating Heap Occupancy 임계 값을 잘 예측할 수있는 충분한 관측치가없는 한 현재 old 세대 크기의 백분율로 초기 값을 결정한다.

#### 마킹

G1 마킹은 *SATB (Snapshot-At-The-Beginning)* 라는 알고리즘을 사용한다. Initial Mark pause에 힙의 가상 스냅샷을 찍는다. 마킹시작시 살아있는 객체는 마킹동안에 살아있는것으로 간주한다. 이로 인해 다른 수집기에 비해 일부 추가 메모리가 잘못 유지 될 수 있다. 그러나 SATB는 잠재적으로 Remark 일시 중지 동안 더 나은 지연시간을 제공한다.

#### 매우 타이트한 힙 상황에서의 동작

애플리케이션이 너무 많은 메모리를 유지하여 비우기시 복사 할 공간을 찾을 수 없는 경우 비우기 실패가 발생한다. 비우기 실패는 G1이 이미 이동 된 개체를 새 위치에 유지하고 아직 이동하지 않은 개체는 복사하지 않고 개체 간의 참조 만 조정하여 현재 가비지 수집을 완료하려고한다는 것을 의미한다. 비우기 실패는 약간의 추가 오버 헤드를 초래할 수 있지만 일반적으로 다른 young collection만큼 빠르다. 비우기 실패와 함께이 가비지 콜렉션 후 G1은 다른 조치없이 정상적으로 애플리케이션을 재개한다. G1은 대부분의 객체가 이미 이동되어 있고 표시가 완료되고 공간 회수가 시작될 때까지 애플리케이션을 계속 실행할 수 있는 충분한 공간이 남아 있는 가비지 수집이 거의 끝날 무렵에 제거 실패가 발생했다고 가정한다.

이 가정이 유지되지 않으면 G1은 결국 Full GC를 예약한다. 이 유형의 콜렉션은 전체 힙의 내부 압축을 수행한다.

#### 거대한 객체

거대한 객체는 영역의 절반보다 크거나 같은 객체이다.

- 모든 거대한 개체는 old 세대의 연속 된 영역으로 할당된다. 객체 자체의 시작은 항상 해당 시퀀스의 첫 번째 영역의 시작 위치에 있습니다. 시퀀스의 마지막 영역에 남은 공간은 전체 개체가 회수 될 때까지 사용할 수 없다
- 일반적으로 거대한 개체는 `Cleanup` 일시 중지 중 또는 Full GC 중 도달 할 수없는 경우 표시가 끝날 때만 회수 할 수 있다. 그러나 `bool` `int`, `double`과 같은 기본 유형의 배열에 대한 거대한 객체에 대해서는 G1은 모든 종류의 가비지 수집 일시 중지시 많은 객체가 참조하지 않으면 거대한 객체를 회수하려고한다. 이 동작은 기본적으로 활성화되어 있지만 `-XX:G1EagerReclaimHumongousObjects`옵션으로 비활성화 할 수 있다 .
- 거대한 객체를 할당하면 가비지 수집 일시 중지가 조기에 발생할 수 있다. G1은 모든 거대한 객체 할당에서 Initiating Heap Occupancy 임계 값을 확인하고 현재 점유율이 해당 임계 값을 초과하는 경우 initial mark young collection을 즉시 시작 할 수 있다.
- 거대한 객체는 Full GC 중에도 움직이지 않는다. 이로 인해 영역 공간의 조각화로 인해 여유 공간이 많이 남아 있어도 Full GC 또는 예기치 않은 메모리 부족 상태가 발생할 수 있다.

#### Young 전용 단계 세대 사이징

young 전용 단계에서 수집 할 지역 집합 (컬렉션 집합)은 young 세대 지역으로 만 구성된다. G1은 항상 다음 예기치 못한 단계를 위해 normal young collection이 끝날 때 young 세대를 측정한다. 이렇게 하면 G1은 -XX:MaxGCPauseTimeMillis 및 -XX:PauseTimeIntervalMillis를 사용하여 설정된 일시 중지 시간 목표를 충족할 수 있다. 일시 중지 시간은 실제 일시 중지 시간의 장기 관측치를 기반으로 한다

#### 공간 재 확보 단계 세대 사이징

공간 회수 단계에서 G1은 한번의 가비지 수집 일시 중지로 old 세대에서 회수되는 공간의 양을 최대화하려고한다. young 세대의 크기는 일반적으로 `-XX:G1NewSizePercent`에 의해 결정되는 최소 허용으로 설정되며, G1에서 추가 영역을 추가하면 일시 중지 시간 목표를 초과한다고 결정할 때까지 공간을 회수할 old 세대 영역이 추가된다. 특정 가비지 콜렉션 일시 정지에서 G1은 교정 효율성, 가장 높은 순서, 최종 콜렉션 세트를 얻기 위해 남은 사용 가능한 시간 순으로 old 생성 영역을 추가한다.

### 다른 Collector와 비교

 주요 차이점

- 병렬 GC는 전체 영역에서만 old 세대의 공간을 압축하고 회수 할 수 있다. G은 이 작업을 훨씬 더 짧은 여러 컬렉션에 점진적으로 작업한다. 이는 처리량의 잠재적인 비용으로 일시 중지 시간을 크게 단축시킨다.
- CMS와 마찬가지로 G1은 구세대 공간 회수의 일부를 동시에 수행한다. 그러나 CMS는 이전 세대 힙을 조각 모음 할 수 없으므로 결국 긴 Full GC로 실행된다.
- G1은 다른 수집기보다 높은 오버 헤드를 나타내어 동시 특성으로 인해 처리량에 영향을 미칠 수 있습니다.

G1에는 가비지 수집 효율성을 향상시키는 몇 가지 고유 한 메커니즘

- G1은 수집하는 동안 old 세대의 완전히 비어있는 넓은 영역을 회수 할 수 있다. 이렇게하면 불필요한 많은 가비지 수집을 피할 수 있으므로 많은 노력없이 상당한 공간을 확보 할 수 있다.
- G1은 선택적으로 Java 힙에서 중복 문자열을 동시에 중복 제거하려고 시도 할 수 있다