## HTTP caching

웹 캐시는 지연시간과 네트워크 트래픽을 줄여줌으로써 리소스를 보여주는 데에 필요한 시간을 줄여준다. HTTP 캐싱을 활용하면 웹 사이트가 좀 더 빠르게 반응하도록 만들 수 있다. 

### 여러 종류의 캐시

캐싱은 주어진 리소스의 복사본을 저장하고 있다가 요청 시에 그것을 제공하는 기술이다. 웹 캐시가 자신의 저장소 내에 요청된 리소스를 가지고 있다면, 요청을 가로채 원래의 서버로부터 리소스를 다시 다운로드하는 대신 리소스의 복사본을 반환한다. 모든 클라이언트를 서비스할 필요가 없어지므로 서버의 부하를 완화하고, (캐시가 원래 서버에 비해서) 클라이언트에 더 가까이에 있으므로 성능이 향상된다. 즉, 리소스를 회신하는데 더 적은 시간이 들게 된다. 웹 사이트에서 캐싱은 높은 성능을 달성하는 데에 주요한 요소이다. 반면에 모든 리소스가 영원히 변하지 않는 것은 아니므로 리소스가 변하기 전까지만 캐싱하고 변한 이후에는 더이상 캐싱하지 않는 것이 중요하다.

캐시에는 몇 가지 종류가 있다. 먼저, 크게 사설(private) 혹은 공유(shared) 캐시 두 가지 부류로 분류될 수 있다. *공유 캐시*는 한 명 이상의 사용자가 재사용할 수 있도록 응답을 저장하는 캐시를 말한다. *사설 캐시*는 한 명의 사용자만 사용하는 캐시를 말한다. 이 페이지에서는 거의 대부분 브라우저와 프록시 캐시에 대해서만 다룰 것이나, 그 외에도 더 나은 신뢰도, 성능 그리고 웹 사이트와 웹 애플리케이션의 확장(scaling)을 위해 웹 서버 위에 배포되는 게이트웨이 캐시, CDN, 리버스 프록시 캐시 그리고 로드 밸랜서 등이 있다.

#### 사설 캐시

사설 캐시는 단일 사용자가 전용으로 사용한다. 브라우저 설정에서 "caching"을 본 적이 있을 것이다. 브라우저 캐시는 그 사용자에 의하여 [HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP)를 통해 다운로드된 모든 문서들을 가지고 있다. 이 캐시는 서버에 대한 추가적인 요청 없이 뒤로 가기나 앞으로 가기, 저장, 소스로 보기 등을 위해 방문했던 문서들을 사용할 수 있도록 해 준다. 또한 유사한 방법으로 캐시된 컨텐츠의 오프라인 브라우징을 개선시킨다.

#### 공유 프록시 캐시

공유 캐시는 한 명 이상의 사용자에 의해 재사용되는 응답을 저장하는 캐시이다. 예를 들어, 당신의 회사의 ISP는 많은 사용자들을 서비스하기 위해 지역 네트워크 기반의 일부분으로서 웹 프록시를 설치해뒀을 수도 있는데, 그 덕분에 조회가 많이 되는 리소스들은 몇 번이고 재사용되어 네트워크 트래픽과 지연을 줄여준다.

### 캐시 동작의 대상

HTTP 캐시들은 일반적으로 GET에 대한 응답만을 캐싱하며, 다른 메서드들은 제외된다.  기본 캐시 키(primary cache key)는 요청 메서드 그리고 대상 URI로 구성된다(GET 요청만을 대상으로 하므로 URI만 사용되는 경우가 많다). 일반적인 캐싱 엔트리의 형태는 다음과 같다.

- 검색(retrieval) 요청의 성공적인 결과

  HTML 문서, 이미지 혹은 파일과 같은 리소스를 포함하는GET 요청에 대한 [`200`](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/200) (OK) 응답.

- 영구적인 리다이렉트

   [`301`](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/301) (Moved Permanently) 응답.

- 오류 응답

   [`404`](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/404) (Not Found) 결과 페이지.

- 완전하지 않은 결과

   [`206`](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/206) (Partial Content) 응답.

- 캐시 키로 사용하기에 적절한 무언가가 정의된 경우의 GET 이외의 응답.

### 캐싱 제어

#### Cache-control 헤더

Cache-control HTTP/1.1 기본 헤더 필드는 요청과 응답 양측 모두에 있어 캐싱 메커니즘을 위한 지시를 지정하는데 사용된다.

##### 캐시하지 않음

캐시는 클라이언트 요청 혹은 서버 응답에 관해서 어떤 것도 저장해서는 안된다. 요청은 서버 측으로 전송되고 전체 응답은 매번 다운로드된다.

```
Cache-Control: no-store
```

##### 캐시하지만 재검증

캐시된 복사본을 사용자에게 릴리즈 하기 전에, 유효성 확인을 위해 원 서버로 요청을 보낸다.

```
Cache-Control: no-cache
```

##### 사설 캐시와 공개 캐시

"public" 지시는 응답이 어떤 캐시에 의해서든 캐시되어도 좋다는 것을 가리킨다. 이것은 HTTP 인증, 혹은 보통 캐시 가능하지 않은 응답 상태 코드를 지닌 페이지가 이제 캐시되어야 할 경우 유용할 수 있다.

반면 "private"은 응답이 단일 사용자만을 위한 것이며 공유 캐시에 의해 저장되어서는 안된다는 것을 가리킨다. 사설 브라우저 캐시는 이런 경우에 응답을 저장할 수 있다.

```
Cache-Control: private
Cache-Control: public
```

##### 만료

"`max-age=<seconds>`"로 리소스가 유효하다고 판단되는 최대 시간을 말한다.  이 지시는 요청 시간에 상대적이며, [`Expires`](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Expires)가 설정되어 있어도 그보다 우선한다. 변경되지 않을 파일에 대해, 공격적으로 (긴 시간으로) 캐싱할 수 있다.

```
Cache-Control: max-age=31536000
```

##### 검증

"`must-revalidate`" 지시 사용 시, 캐시는 오래된 리소스를 사용하기 전에 그 상태를 확인하고 만료된 리소스는 사용하지 말아야 한다

```
Cache-Control: must-revalidate
```

#### Pragma 헤더

Pragma는 HTTP/1.0 헤더이다. `Pragma: no-cache`는 캐시가 검증을 위해 원래 서버에 요청을 보내도록 강제한다는 점에서 `Cache-Control: no-cache`와 유사하다. 그러나 `Pragma`는 HTTP 응답에 대해 명세되지 않았으므로 일반적인 HTTP/1.1 `Cache-Control` 헤더를 신뢰성 있게 대체할 수 없다.

`Cache-Control` HTTP/1.1 헤더가 없는 HTTP/1.0 클라이언트와의 하위 호환성을 위한 경우에만 `Pragma`를 사용하여야 한다.

### 유효성

캐시는 유한한 저장 공간을 가지므로 아이템들은 주기적으로 스토리지에서 제거된다. 이런 과정을 *캐시 축출(cache eviction)*이라고 부른다. 반면 어떤 리소스들은 서버 상에서 변경될 수 있고, 캐시가 갱신되어야 한다. HTTP가 클라이언트-서버 프로토콜이므로, 리소스가 변경됐을 때 서버는 캐시와 클라이언트에 접근할 수 없다. 서버는 리소스에 대한 만료 시간을 알려줄 수밖에 없습니다. 만료 시간 이전에는, 리소스가 *유효(fresh)*합니다; 만료 시간 이후의 리소스는 *효력이 없어지게(stale)*됩니다. 캐시 축출 알고리즘은 효력이 없어진 리소스를 바로 축출하지 않고 유효한 리소스보다 높은 순위로 축출한다. 캐시가 효력이 없어진 리소스에 대한 요청을 받은 경우, 리소스가 실제로 유효한지 아닌지 확인하기 위해 [If-None-Match (en-US)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match)와 함께 요청을 전달한다. 유효하다면, 서버는 요청된 리소스 본문을 전송하지 않고 [`304`](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/304) (Not Modified) 헤더를 돌려보내 대역폭을 절약한다.

유효 수명은 몇가지 헤더에 근거해 계산됩니다. "`Cache-control: max-age=N`" 헤더가 설정된 경우, 유효 수명은 N과 동일합니다. 만약 이 헤더가 없다면, [`Expires`](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Expires) 헤더가 있는지 없는지를 검사합니다. `Expires` 헤더가 존재한다면, 그것의 값에서 [`Date`](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Date) 헤더의 값을 뺀 결과가 유효 수명이 된다

#### 리비전된 리소스

캐시된 리소스들을 많이 사용할수록, 웹 사이트의 응답성과 성능은 점점 더 좋아질 것이다. 이것을 최적화하기 위한 좋은 방법은 만료 시간을 가능한 더 먼 미래로 설정하는 것이다. 하지만, 드물게 업데이트되는 리소스의 경우에 캐시가 문제가 될수 있다. 이런 리소스들을 캐시하면 이득이 크지만, 업데이트하기가 매우 어렵다. 

웹개발자들은 리비전이라는 기술을 만들었다. 드물게 업데이트되는 파일들은 특정한 방법으로 이름붙여진다: 파일들의 URL내에, 보통 파일명에, 수정(혹은 버전) 번호가 추가됩니다. 그렇게 해서 해당 리소스의 각각의 새로운 수정본 자체는 결코 변경되지 않으며, 보통 1년 혹은 그 이상의 아주 먼 미래로 만료 시간이 설정될 수 있다. 드물게 변경되는 리소스들이 변경되는 경우 자주 변경되는 리소스에 추가적인 변경을 한다. 이런 리소스들이 읽혀지는 경우, 다른 리소스들의 새로운 버전들도 읽혀지게 된다.

### 캐시 검증

캐시된 문서의 만료 시간이 가까워져오면, 문서가 검증되거나 다시 불러오게 된다. 검증은 서버가 *강한 검증* 혹은 *약한 검증* 중 하나라도 제공하는 경우에만 일어날 수 있다.

재검증은 사용자가 리로드 버튼을 누를 경우 발생된다. 재검증은 캐시된 응답이 "`Cache-control: must-revalidate`" 헤더를 포함하고 있는 경우 일반적인 브라우징 중에도 촉발될 수 있다. 또 다른 요인은 `Advanced->Cache` 환경설정 패널 내에 캐시 검증 환경 설정입니다. 거기에는 문서가 로드될 때마다 검증을 강제할 수 있는 옵션이 있다.

#### ETags

ETag 응답 헤더는 강한 검증으로써 사용될 수 있는 *사용자 에이전트에게 있어 불투명한(opaque)* 값이다. 사용자 에이전트가 이 문자열이 무엇을 표현하는지 알 수 없고, 그것의 값이 무엇이 될지를 예측할 수 없다는 것을 의미한다.  `ETag` 헤더가 리소스에 대한 응답의 일부라면, 클라이언트는 이후 요청의 해더 내에 (캐시된 리소스를 검증하기 위해) [If-None-Match (en-US)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match)를 줄 수 있다.

#### Last-Modified

Last-Modified 응답 헤더는  약한 검증으로써 사용될 수 있다. 클라이언트는 캐시된 문서를 검증하기 위해 [`If-Modified-Since`](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/If-Modified-Since) 요청 헤더를 줄 수 있다.

검증 요청을 받으면, 서버는 검증 요청을 무시하고 일반적인 [`200`](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/200) `OK`으로 응답하거나, 브라우저에게 캐시된 복사본을 사용하도록 지시하기 위해 [`304`](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/304) `Not Modified` (본문을 비워둔 상태로)를 반환할 수 있다. 

### Vary 응답

[`Vary`](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Vary) HTTP 응답 헤더는 원 서버로부터 새로운 리소스를 요청해야 하는지 캐시된 응답이 사용될 수 있는지를 결정하기 위해 이후의 요청 헤더를 대조하는 방식을 결정한다.

캐시가 `Vary` 헤더 필드를 지닌 요청을 수신한 경우, `Vary` 헤더에 의해 지정된 모든 헤더 필드들이 원래의 (캐시된) 요청과 새로운 요청 사이에서 일치하지 않는다면 그 캐시된 응답을 사용해서는 안 된다.

이 기능은 컨텐츠를 비압축 또는 (여러 가지) 압축 포맷으로 캐시될 수 있도록 하고, 유저 에이전트가 지원하는 포맷에 따라 제공하도록 할 때 흔히 사용된다. 예를 들어 서버는 `Vary: Accept-Encoding`을 설정하여 특정한 집합의 인코딩을 지원하는 (예를 들어 `Accept-Encoding: gzip,deflate,sdch`) 모든 요청들에 대해 각각 다른 버전의 리소스를 캐시하도록 할 수 있다.

`Vary` 헤더는 데스크탑과 모바일 사용자에게 서로 다른 컨텐츠를 제공하거나, 검색 엔진에게 페이지의 모바일 버전을 발견할 수 있게 하는 (그리고 [클로킹](https://en.wikipedia.org/wiki/Cloaking) 의도가 없다고 알려주는) 데에도 유용하다. 이것은 보통 `Vary: User-Agent` 헤더를 사용해서 할 수 있다. [User-Agent (en-US)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent) 헤더 값이 모바일과 데스크탑 클라이언트 간에 서로 다르기 때문이다.

```
Vary: User-Agent
```