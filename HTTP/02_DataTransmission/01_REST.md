## REST

**Representational state transfer(REST)** 는 HTTP 하위의 소프트웨어 아키텍처 스타일이다. 일반적으로 웹 서비스를 사용하는 상호작용하는 애플리케이션을 만드는데 사용되고 이러한 가이드 라인을 따르는 웹서비스를 RESTful 이라고 부른다.

### REST 아키텍처의 제약사항

#### Client-server architecture

클라이언트 서버 제약의 이유는 관심사의 분리이다. 사용자 인터페이스와 데이터 스토리지를 분리하여 여러 플랫폼에서의 사용자 인터페이스 이식성이 향상된다. 또한 서버 구성 요소를 단순화하여 확장성을 향상시킨다. 가장 중요한 점은 구성요소 각각의 독립적인 진화를 보장할 수 있다.

#### Statelessness

Stateless 프로토콜은 수신자인 서버가 세션 정보를 가지고 있지 않는 통신 프로토콜이다. 관련 데이터는 이전 세션의 패킷의 정보 없이 모든 패킨 정보는 분리된 상태로 이해할 수 있어야한다. 이러한 stateless로 세션 정보 보존으로 인한 자원 사용을 제거하여 서버의 성능향상에 도움을 준다.

#### Cacheability

World Wide Web에서와 같이 클라이언트와 중개자는 응답을 캐시 할 수 있다. 응답은 캐시 가능 또는 캐시 불가능을 명시해야 한다.

#### Layered system

클라이언트는 end서버에 직접적으로 연결되어 있는지 중간에 다른것을 거치는지 알수 없다. 중간에 서버를 두어 로드 밸런싱 캐시 공유 등을 제공하여 시스템을 구성할 수 있다.

#### Code on demand (optional)

서버는 실행 가능한 코드(Java applets, JavaScript) 등을 포함해서 보낼 수 있다.

#### Uniform interface

Uniform interface 제약은 모든 RESTful 시스템 설계의 기본이다. 아키텍처를 단순화하고 분리하여 각 부분이 독립적으로 발전 할 수 있도록한다.

- **Resource identification in requests (자원의 식별)**

  각각의 리소스는 요청에서 식별된다.(URI등을 이용) 리소스는 개념상 클라이언트에 반환되는 표현(HTML, XML, JSON 등)과 분리된다.

- **Resource manipulation through representations(메시지를 통한 리소스의 조작)**

  클라이언트는 서버로부터 리소스의 메타데이터를 포함한 리소스의 표현을 받고 이 표현은 리소스의 상태를 수정하거나 삭제할 수 있는 충분한 정보를 포함하고 있다.

- **Self-descriptive messages(자기 서술적 메시지)**

  각 메시지는 메시지를 처리 방법을 설명하기에 충본한 정보가 포함하고 있다. 예를 들어 미디어 타입으로 어떻게 파싱할 수 있는지 알 수 있다.

- **Hypermedia as the engine of application state(HATEOAS, 애플리케이션의 상태에 대한 엔진으로서 하이퍼미디어)**

  REST 애플리케이션의 처음 URI에 접근한 REST 클라이언트는 서버가 제공하는 링크를 동적으로 사용하여 필요한 모든 리소스를 동적으로 사용하여 필요한 모든 리소스를 검색 할 수 있어야 한다. 접근에 대해서 서브는 현재 사용 가능한 다른 리소스에 대한 하이퍼링크가 포함된 텍스트로 응답한다. 클라이언트가 애플리케이션의 구조에 관한 정보로 하드 코딩 될 필요가 없다